条款32：使用初始化捕获将对象移入闭包


C++11 中没有提供将对象移动进入闭包的方式，但是 C++14 直接支持将对象移入闭包
当然 C++11 还是可以近似实现这一操作的

C++14 提供的初始化捕获可以胜任除了默认捕获模式外的所有工作，当然上个条款警告过你不要用默认捕获模式了
但是语法相对 C++11 没有那么简练，如果可以用的话当然可以继续使用 C++11 的捕获
使用初始化捕获，你将有机会指定：
    1.由 lambda 生成的闭包类中的成员变量的名字
    1.一个表达式用以初始化该成员变量

这里有个例子：
    auto pw = std::make_unique<Widget>();
    auto func = [pw = std::move(pw)]{
        return pw->isV() && pw->isA();
    }
然后有意思的地方出现了，这里的 pw = std::move(pw) ,中两个 pw 的作用域不一样呐，左侧的 pw 是闭包中的成员变量，作用域为闭包内，
而右侧的 pw 则是上面定义的 auto pw = std::make_unique<Widget>(); 所以两者并不是同一个东西呢

如果你的 pw 没有其他作用，甚至可以直接使用 make_unique 来进行初始化： auto func = [pw = std::make_unique()]
这也表现了捕获概念在 C++14 中得到了显著的泛化，所以初始化捕获也称为“广义lambda捕获”

作者在书中提供了C++11的解决办法，这里没办法使用 lambda 但是一样可以手动来解决，代码太长我看的实体书就不抄了蒽（p214）
来理一理代码哈，创建了一个表示已校验并归档的类，然后成员为智能指针对 pw ，在构造函数中调用 pw 的移动构造函数来构造 pw
但是讲道理重载 () 我看傻了，我猜测是为了生成一个函数对象，然后这样调用的时候可以直接使用 func();

还有可以使用 lambda 表达式的办法：
    1.把需要捕获的对象移动到 std::bind 产生的函数对象中
    2.给 lambda 表达式一个指向想要捕获对象的引用
这种方式是使用 std::bind 来代替 lambda 生成需要的函数对象