条款28：理解引用折叠


实参在传递给函数模板时，推导出来的模板形参是左值还是右值将会以推导出 T 的类型来保存在推导结果中
如果实参是左值， T 将会是左值引用类型，而如果实参是右值， T 将会是非引用类型

仔细观察你可能会发现，这样的话，万能引用的推导结果会变成这样 Widget& &&，也就是引用的引用
在C++语法中你是不能定义一个引用的引用的，但是编译器可以在某些特殊语境下产生这种引用的引用，模板实例化就是这样的语境之一

引用有左值引用和右值引用，也就是会有四种引用组合（左左、右右、左右、右左）
如果这些组合出现在允许引用的引用的语境中，双重引用会折叠成单个引用，也就是引用折叠

引用折叠的规则是：只要有左值引用则结果为左值引用，只有两个都为右值引用时结果才是右值引用

引用折叠规则是使 std::forward 正常运作的关键

std::forward 的运作大致为这样（作者提供）：
template<typename T>
T&& forward(typename remove_reference<T>::type& param) {
    return static_case<T&&>(param);
}

来看看这段实现，是不是一眼看上去，这咋还没有判断类型呢，再想想引用折叠，就明朗了，因为这里做的不是判断类型，而是针对不同情况改变了返回类型
对于这个函数我们可能会使用两种实参，也就是左值和右值，对于左值，类型推导为左值引用，返回值类型也就是 Widget& &&，
根据引用折叠原则返回类型为左值引用，也就是强制类型转换什么都没做
而对于右值，类型推导结果为 Widget&& 也就是右值，强制类型转换会将 param 转换为 Widget&& 也就完成了转换为右值的操作

引用折叠会出现的语境有四个分别为：模板实例化、 auto 类型变量的类型形成、生成和使用 typedef 和别名声明、运用 decltype
显然都涉及到类型推导蒽

回过头来这时再看万能引用，实际上它并不是一个单独的引用类型，而是一个类型推导过程中会区别左值右值而且会发生引用折叠的右值引用
简单点说就是一个特殊的右值引用蒽
在我看来引用折叠更像是一个为了防止在类型推导中出现引用的引用这种情况而出现的防治措施？