条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递


首先要说明的是这里的复制指的是用作复制或者移动的源
如果你希望一个函数当传入实参为左值时进行复制，对传入的实参是右值时进行移动，那么你肯定首先会想到重载函数和万能引用
但是呢首先重载需要两个函数，连作者都知道现在人越来越懒惰了
其次万能引用，看似很好但是实则有潜在问题：
    1.作为模板，这个函数的实现必须在头文件中，别的不说，光看起来就不整洁
    2.他还可能在对象代码中产生很多个函数，因为是模板嘛，他不止针对左值和右值会产生不同的实例化结果
    3.有些类型不能按引用传递，如果传入了错误的类型，编译器错误消息可能很难看懂

换言之，我们想要万能引用的功能，但是不想要模板
如果想解决这些问题，可能你要放弃学习C++中学到的第一条规则，就是避免按值传递用户定义类型的对象
因为在书中举例中的情况下，按值传递可能是个完全合理的选择，他长这样
    void addName(std::string newName) {
        names.push_back(std::move(newName));
    }
这应该是在新手阶段最常见的版本了吧，除了 move ，解释一下因为这里是按值传递的，如果传递的是右值 newName 也只是右值的
一个副本，对其进行移动不会对原本的对象有任何影响！那么成本呢？
对于 c++98 来说，成本会变高，因为无论传入的是什么，都会经过一次复制构造，但是在 c++11 中，当传入的参数是右值时，他会
被移动构造！例如这样：
    a.addName(name + "jim");
由于 operator+ 的缘故，参数被构造为右值，我的理解是，因为经过 operator+ 后的对象不是 name 所以不应该更改 name 所以
会构建一个新的右值对象

现在来回顾一下三个方案：重载，万能引用，啥也不干（按值传递
然后分析一下成本问题，
    重载：针对左值进行一次复制，右值进行一次移动
    万能引用：针对左值一次复制，右值一次移动（如果传入的实参不是 string 类型，则会被转发到 string 的构造函数，可能一次
    移动或复制都没有！
    按值传递：针对左值进行一次复制一次移动，针对右值进行两次移动（都会有一次移动是将形参移入容器

回头来关注一下这章标题的“在移动成本低并且一定会被复制的前提下”，这么说主要有四点原因：
    1.你只需要考虑按值传递
    2.仅对于可复制的形参才考虑按值传递，因为对于只移对象而言，不需要提供针对左值实参的重载！
    3.按值传递仅在形参移动成本低廉的情况下才考虑，而且你应该只针对一定要进行复制的参数才考虑按值传递，因为如果不一定发生复
    制而去按值传递的话，无论有没有复制你都要担负一次临时对象构造和析构的成本
    4.不同于按引用传递，按值传递比较容易遇到切片问题（将子类转为父类同时切除不是父类的部分