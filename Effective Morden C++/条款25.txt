条款25：针对右值引用实施 std::move ，针对万能引用实施 std::forward


这次上来直接看一个移动构造函数：
    Widget(Widget&& rhs):name(std::move(rhs.name)),p(std::move(rhs.p)) {}
诶嘿，是不是发现，明明写了 rhs 是右值引用，结构下面还要强制转换
我的理解是， Widget&& rhs 的声明只是保证 rhs 会绑定一个右值，换句话说，要求你传入一个右值
但是由于 rhs 是形参，他依然是一个左值，所以需要强制转换蒽，但是我自己总感觉这么理解不太对的亚子

再看一个进行了移动操作的函数：
    template<class T>
    void setName(T&& newName) {
        name = std::forward<T>(newName);
    }
可见 newName 是一个万能引用，这意味着它可能被绑定到左值或右值，也就不再限制实参为右值了！
显然如果在这里依然使用 move 会错误的将传入的左值也转为右值，这一定不符合你的预期
毕竟你肯定希望这个函数在传入能移动的实参时使用移动操作，否则使用复制操作
forward 帮我们解决了这个问题，仅当实参是右值是才将 newName 转为右值

万能引用让我们用一个模板函数实现了需要重载两个版本函数（一个针对左值一个针对右值）的功能，
同时，即使你实现了针对右值的重载：
    void setName(string&& newName) {
        name = newName;
    }
其效率也不如万能引用的版本，原因是重载的 setName() 还要多执行一个 string 临时对象的构造和析构
这还不是最可怕的，更可怕的情况是，如果你的函数有多个形参，并且每个都有左值和右值两种情况，你需要的重载数量emmmm
想想就可怕吧

万能引用还有更多奇妙的用处（还说C++不是魔法？）
看这个函数：
    template<class T>
    void setSignText(T&& text) {
        sign.setText(text);
        signHitory.add(std::forward<T>(text));
    }
这样，我们可以保证在 add 之前不改变text，原因和上面差不多
text 是一个左值，所以传入setText()并不会改变他的值，然后当我们想要他进行移动操作的时候
通过 forward 强制转换为右值，然后进行移动操作，当然如果传入的实参是左值，也不会发生可怕的事情
反正我觉得不会蒽（越学越不敢把话说的太满了）

作者说很少情况下需要将 std::move 替换成 std::move_if_noexcept，先记下来蒽，这会儿是没时间回去往前翻了

在按值返回的函数中，如果返回的是一个绑定到右值引用或万能引用的对象，则应该在返回时对其使用 move 或 forward
当然也是对于绑定到右值的使用 move ，对于绑定到万能引用的使用 forward
因为对于一个绑定到右值的形参，因为形参是左值，返回其本身会发生一次复制，也就是将其复制进返回值，
但是将其转换为右值后，复制行为会被替换成移动
例如在一个矩阵加法的 operator+ 重载中：
    Matrix operator+(Matrix&& lhs, const Matrix& rhs) {
        lhs += rhs;
        return std::move(lhs); //如果不使用 move 则会发生复制
    }
而万能引用也同理，如果是左值按复制将值传给返回值，如果是右值则使用移动操作

当然你会发现这东西很好用，然后想到了用他来优化函数的返回值:
    Widget makeWidget() {
        Widget w;
        return std::move(w);
    }
然而这并构不成优化，因为C++标准对返回值是有优化的！也就是RVO
需要满足两个前提条件：局部对象（不包括参数）和返回值类型相同，返回的是局部对象本身
手动改为移动操作则反而阻止了编译器帮你做的优化！
原因是return std::move(w);返回的是一个引用，而不是w本身！
RVO会直接使局部对象创建在返回值的内存中，也就是既不会移动更不会复制，显然比移动还要高效！
标准中还说明，当满足RVO条件单编译器没有选择执行复制省略时，返回对象必须按右值处理，也就是你就算不转换他也是右值！