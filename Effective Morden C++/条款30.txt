条款30：熟悉完美转发的失败情形


完美转发是转发对吧，转发就是将一个函数自己的形参传递给另一个函数而已
我们希望函数可以处理原本传入的对象，而且不希望强制用户传递一个指针，所以一般意义上的转发都是在处理以引用作为形参
而完美则是说我们不仅转发形参，还转发其显著特征如：类型、左值右值、修饰词等

一种符合逻辑的拓展为让转发函数不只是模板函数，还是可变长形参模板函数，从而来接受任意数量的实参
长这样：
template<typename... Ts>
void fwd(T&&... params) {
    f(std::forward<Ts>(params)...);
}
给定目标函数 f 和转发函数 fwd 当以某特定实参调用 f 会执行某操作，而用同一实参调用 fwd 会执行不同操作则称完美转发失败

简而言之完美转发会在下面两种情况下失效：
    1.编译器无法为一个或多个 fwd 的形参推导出类型
    2.编译器为一个或多个 fwd 的形参推导出了错误的类型

当然可以看到问题出在实参类型推导上上，某些特定的实参会导致完美转发失败


大括号初始物
例如一个 f 函数：void f(const std::vector<int>& v);
当你使用这种调用时:f({1,2,3})；
编译器会对实参和形参进行比较，类型不一致时会进行隐式类型转换，这里就使用{1,2,3}来创建了一个临时 vector 作为实参
但是由完美转发实施的对 f 的间接调用则会让编译器不去比较实参和 f 的形参，取而代之的是进行推导传递给 fwd 的形参
然后将推导结果来和 f 的形参对比，然后由于 fwd 的形参并没有声明为 std::initializer_list 编译器也就禁止从{1,2,3}发出的类型推导

之前在条款2说过，auto 会将{1,2,3}这种形式推导为 std::initializer_list 那么就得到了一个简单的解决办法
因为编译器只是禁止对{1,2,3}这种形式的推导，而不禁止对 std::initializer_list 的类型推导
所以如果你想传递的是一个 std::initializer_list 的话，可以使用 auto 先声明一个局部变量，像这样：
auto li = {1,2,3};  //被推导为 std::initializer_list
fwd(li); //传递了一个 std::initializer_list


0和 NULL 用作空指针
之前就曾讨论过，如果用 0 或 NULL 来表示空指针会在类型推导时得不到想要的结果，因为 0 和 NULL 只是以前没有 nullptr 时没办法的办法
而随着模板和 auto 的引入，C++ 标准同样提供了 nullptr 这么好用的东西来专门表示空指针而不会导致错误的类型推导
所以你还有什么理由不用它呢（其实我猜是因为入门用的书里没有讲所以压根不知道有这么个东西，条款8里面详细讲了，忘记的话回去复习复习


仅有声明的整型 static const 成员变量
有个普适的规定：不需要给出类中的整型 static const 成员变量的定义，仅需声明，因为编译器会根据这些成员的值实施常数传播，，从而不必再为他们保留内存
注意哈，这里没有为它保留内存，所以在对其取地址时会有问题，因为这玩意莫得地址
然而万能引用也是引用对伐，在生成的机械码中引用通常是当指针处理的，嘿嘿嘿你猜猜你向一个需要指针的函数传递了一个莫得地址的实参会出现啥结果
解决办法也很简单，就是在 .cpp 文件中为其加上定义就好了


重载的函数名字和模板名字
我们来假设 f 需要传入一个执行部分操作函数来定义其行为：void f(int (*pf)(int));
假设有重载函数 int processVal(int value)； int processVal(int value, int priority);
如果直接使用 f(processVal); 是可以得到想要的结果的，因为 f 的参数列表会匹配到只有一个参数的 processVal
但是 fwd(processVal) 则不能成功，因为作为函数模板，他是去通过参数推导类型的，但是这东西是个重载了的函数名，究竟该推导为哪个？
同样的问题出现在 processVal 为函数模板的时候，因为对于一个函数模板， fwd 同样不能去推导他的类型
想让 fwd 在这种情况下正常工作，只有手动指定需要转发的那个重载版本或实例，当然一般来说这样就会需要一个临时变量了


位域
看一个例子：
struct IPv4Header {
    std::uin32_t version:4,
                 IHL:4,
                 DSCP:6,
                 ECN:2,
                 totalLength:16;
}
IPv4Header h; 
同样我们直接调用 f 不会出问题：f(h.totalLength);
但是呢，偏偏不能使用 fwd ： fwd(h.totalLength);
fwd 的形参是引用，而 h.totalLength 则是个非 const 的位域，C++标准中规定了：非 const 引用不得绑定到位域
因为位域是由机械字的若干任意部分组成的，也就以为这不可能对其直接取地址
由于任何接收位域实参的函数都只能得到其副本，这样的话，我们可以自己制作一个副本，然后让 fwd转发他，毕竟你再怎么努力，也只能是操作其副本