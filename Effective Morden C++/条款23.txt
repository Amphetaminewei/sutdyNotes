条款23：理解 std::move 和 std::forword


简单来说吧， move 不进行任何移动， forword 也不进行任何转发
他们都只是执行强制类型转换的函数模板

move 的形参是一个万能引用，并且返回一个右值引用
换句话说 move 就是帮你把对象转化成右值引用的
并且 move 通过 std::remove_reference 来保证 && 会作用在T之上，从而来保证返回的一定是右值引用
对，没了，他就做这点事，和移动操作并没有关系
在一个对象使用 move 意思是高速编译器这个对象具有了进行移动操作的条件了

但是，试图对 const 对象进行移动操作一般是被拒绝的，因为将值移出对象通常会改动该对象，
所以编译器在面对这些选择时，一般会选择不声不响的去调用复制操作
所以，对于想要进行移动操作的对象，不要声明为const，同时我们可以发现，即使是右值，也不保证会进行移动操作
也就是 move 保证返回一个右值但是不保证会进行移动！

而 forword 呢，其实差不多，但是他是将右值转换为右值，是不是有点假
因为函数的形参，全都是左值，即使你传入一个右值实参，也会将形参构造为左值，
这个时候就是由右值实参构造的形参再转化为右值
还挺拗口

而实参是否为右值的信息，被编码保存在函数的模板形参 T 中，该形参传递给 forward 后将编码信息恢复出来
听着还挺神奇，不过C++是魔法语音是众所周知的蒽

虽然两者差不多，但是还是有各自的使用情景的（除非硬要抬杠，毕竟这俩没有也不是不可以
forward 一般都是使用在函数中，就像上面的用法，而其他情况基本上都是用 move

move 比 forward 打字要少！（众所周知程序员一个比一个懒蒽
也省去了需要传递一个类型实参且由他编码的须是右值类型的麻烦
还消除了传递错误类型的可能

总结一下，使用 move 传达的意思是无条件的强制转换为右值，而 forward 则是想说明仅仅对绑定到右值的引用实施强制类型转换