使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中

Pimp意味“point to implementtation”，即指向实现的指针
这种技巧是把数据成员用指向某实现类或结构体的指针代替，然后把主类中的数据成员放置到实现类中，并可以通过指针访问
例如：
//demo.h
    class demo {
    public:
        demo();
        //~demo();
    private:
        struct Impl;
        std::unique_ptr<Impl> pImpl;
    }

//demo.cpp
    #include"demo.h"
    #include"otherClass.h"
    #include<string>
    #include<vector>

    struct demo::Impl{
        std::string name;
        std::vector<double> data;
        otherClass o1;
    };

这样可以让demo.h不需要include需要的类，只需要在实现文件中添加他们，
这样一来在这些被include的类更改时，头文件就不需要被重新编译

同时显然我们想要pImpl可以自动析构，而且它绝不会你也不会想要它被共享所有权，
所以在这里很适合unique_ptr

但是，这个类，它是错的
因为在demo的对象析构时，我们没有为他实现析构函数，编译器会帮你实现一个，unique_ptr默认析构器是使用delete来针对裸指针，
而在执行delete之前，编译器大多会使用static_assert去确保裸指针指向了完整的类型，而我们的问题就出在这里，
由于编译器生成的析构函数大多是隐式inline的，而对于一个inline函数，它的执行在我们的Impl实现之前，
也就是执行到析构函数时，类型都还不是完整的，都是只有实现么有定义的

解决办法也不复杂，就是保证在析构函数执行时， Impl 已经是一个完整的类型，
说起来复杂，其实你只需要将析构函数的实现写在 struct 的定义后面就成了，
如果你想用编译器帮你生成的默认析构函数，那就在 struct 定义的后面加上 demo::~demo() = default;

前面的章节提到过，声明了析构函数，编译器就不会帮你生成默认移动构造函数和移动操作符了，你需要手动把他写上去
但是注意，你还是需要同析构函数一样保证它执行时 Impl 已经是一个完整类型了
原因是移动的操作符会导致原本的对象被析构，看吧，还是析构
而移动构造函数是编译器在移动构造函数内抛出异常会生成析构 pImpl 的代码，看，还是析构
处理方法和之前一样，手动实现在 Impl 定义的后面

如果我们的demo应该支持复制的话，你同样需要手动去写一个实现，原因是：
    1.编译器不会为只移类型生成复制操作（unique_ptr)
    2.即使生成了也只是对对象进行浅复制（只复制unique_ptr）

好了回忆一下浅复制和深复制，浅复制相当于和原本的指针指向同一块内存，而深复制才是将内存里的内容复制到另一块内存中

这里我们只提到了 unique_ptr 而没有提到 shared_ptr，因为两者在实现 pImpl 时行为不同，因为他们对自定义析构器不同
unique_ptr析构器类型是自身类型的一部分，在性能上更高效，但是带来的问题就是，如果要使用编译器生成的特种函数，则需要指向完整的类型
而 shared_ptr 则没有这种限制
但是换过来想想 Pimp 用法的情况，这种情况中 Impl 的所有权一定是专属的，不可更改的，你并不会用到 shared_ptr ，它反倒会让程序臃肿