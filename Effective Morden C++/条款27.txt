条款27：熟悉依万能引用类型进行重载的代替方案

条款26解释了为什么不能对万能引用函数进行重载，本条款将提供一些代替方案

1.舍弃重载
    简单粗暴，但是对于使用构造函数进行完美转发的情况不合适，因为构造函数名字不能变蒽

2.传递 const T& 类型的形参
    使用左值引用代替万能引用，换句话说就是放弃万能引用

3.传值
    使用传值代替万能引用，同样是放弃万能引用

4.标签分派
    函数调用时的重载决议会考察所有重载版本的形参和形参并将所有情况考虑在内选择最佳的组合
    而让我们难以使用重载的是万能引用的形参会导致无论传入实参什么万能引用都是精确匹配
    而这个方式相当于曲线救国，放弃重载万能引用函数，而是将需要重载的部分委托给其他函数，
    一个用来接收整形值，一个接收其他所有类型
    这里是用了两个重载的函数 logAndImpl(std::forward<T>, std::is_integral<typename std::remove_reference<T>::type>)
    对于接收非 int 类型的重载直接完成原本的功能，而接收 int 类型的重载则调用函数获取该 index 的内容，并以此为参数重新调用一次 logAndAdd
    问题解决了，万能引用为形参的函数现在不需要重载了，重载的函数也不包含万能引用了

5.对接收万能引用的模板施加限制
    标签分派的形式依旧不适合完美转发构造函数，因为万能引用让标签分派函数包揽所有的构造
    使用标准库提供的 std::enable_if 可以让你把含有万能引用的函数模板被允许采用的条件砍掉一部分
    std::enable_if 可以强制编译器表现出来的行为如同特定模板不存在，只有在满足 std::enable_if 的条件后才会启用
    然后模板的神奇之处还不止这点
    std::is_same 可以判断两个类型是否一样，如果是person类型则调用正常的复杂/移动构造函数，否则调用完美转发函数
    std::decay 则可以消除类型的修饰，也就是去掉引用、常量等修饰，用来保证 std::is_same 的结果正确
    但是，还是继承问题，子类的复制构造函数还是会调用父类的完美转发函数，因为类型不同蒽
    所以需要将 std::is_same 替换成 std::is_base_of 来判断是否继承，而由于所有类型的可以认为是自身的子类所以可以代替原本 std::is_same 的功能
    在C++14下，可以用别名模板来让代码更简练一丢丢
    总结一下也就是，在模板上限制类型不为其派生类并且不为 int 时启用模板
    可能这就是模板元编程的胜利吧

    总的看来，只有后两种方法能让你不放弃万能引用，但是一个比一个复杂
    完美转发效率虽然高，但是有些类型不能使用
    而且后两种方法在用户传入非法参数时，会带来很刺激的错误信息，至于有多刺激呢，作者说他用的某个编译器有160多行
    std::is_constructible可以在编译器判断某个类型的对象是否从另一类型的对象出发完成构造