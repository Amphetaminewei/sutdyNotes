条款31：避免默认捕获模式


C++11中有两种默认的捕获模式：按值和按引用
按引用的默认捕获模式可能导致悬空指针，按值的默认捕获模式可能会让你以为可以免疫悬空引用并让你以为闭包是独立的

按引用捕获会导致闭包包含指向局部变量的引用或指向定义 lambda 式的作用域内的形参的引用
就像书中用例一样，即使在此处没有悬空引用的危险，如果这个 lambda 表达式可以用在程序的其他地方，将其复制粘贴过去也很容易发生危险
这个问题可以通过使用按值的默认捕获模式解决，但是按值传递也不能完美解决指针副本可能悬空的问题
因为通过按值捕获一个指针副本也不能防止在 lambda表达式 之外的地方将原本的指针 delete 的可能，这样同样会使 lambda表达式 中的副本悬空
捕获只能针对创建在 lambda表达式 作用域中的非静态局部变量呦，不要试图去捕获其他的东西比如成员变量之类
如果你想捕获成员变量，可以创建一个它的副本然后将副本捕获，在C++14中更好的方式是使用广义 lambda 捕获（相当于在捕获时创建一个副本然后捕获，本质似乎差不多）

使用默认捕获模式的另一个缺点是在于他似乎表明闭包是自洽的，与闭包外的数据变化绝缘
而 lambda表达式 可能还会依赖静态存储期对象，这些对象可以在 lambda表达式 中使用但是不能被捕获
而默认值捕获模式会让人产生这些对象可以被捕获的错觉

简单点说吧，这是让你避免产生幻觉而且让你的代码同样不容易让别人产生幻觉的好习惯

倒是有个好消息是C++14中提供了在 lambda表达式 使用 auto 的功能