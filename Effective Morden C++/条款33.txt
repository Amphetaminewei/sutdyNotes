条款33：对 auto&& 类型的形参使用 decltype ，以 std::forward 之


泛型 lambda 表达式是C++14最振奋人心的特性之一，让 lambda 可以在形参规格中使用 auto
其实现是通过将闭包内的 operator() 该为模板实现，由于 lambda 表达式的类型是闭包类型，是一种带有 operator() 的仿函数对象，可以按照函数调用的手法调用
所以重载了 operator() 后，参数可以使用模板进行推导，也就可以使用 auto 了（这是我自己的理解蒽

类型推导加上标题的 auto&& 反正我是一下想到了完美转发，书中给了这个：
    auto f = [](auto&& x){
        return func(normalize(std::forward<???>(x)));
    }
对，调皮的作者在 forward 的类型中写的是？？？，起初我还以为这是什么特别的功能的写法emmmmm
一般的完美转发都是和模板配套使用的，你可以理所应当是使用 T ，但是这莫得模板，而且 operator() 中的模板也无从使用
那咋办嘛

来复习一手，前面讲过的关于 std::forward 的实现：
    template<class T>
    T&& forward(remove_reference_t<T>& param){
        return static_cast<T&&>(param);
    }
再复习一下万能引用，如果传递给万能引用的形参是左值，则会成为左值引用，而右值形参则会成为非引用
如果是左值，引用折叠下的结果是右值，而如果传递到 forward 的类型为非引用类型，则会返回右值

简单来说，对于 forward ，一般在其<???>中类型为左值引用时，返回值是左值引用，而当其为非引用类型时返回右值，这是引用折叠导致的
那么如果传入类型是右值引用呢
在引用折叠的作用下，返回的同样是右值引用

为啥复习了这么多呢，因为有个前面讲过的东西 decltype ，他会将左值处理为左值引用右值处理为右值引用，诶嘿，是不是一下就明朗了
可以在上例中，用 decltype(x) 来代替常见的 T ，由于 x 的类型是推导而来的，所以也可以实现一样的效果呢

这么看来好像没一开始看着那么神奇了，总结一下吧，知识点都是前面讲过的：
    首先，不论实参是左值右值，传入函数后形参都是左值，所以才需要使用 forward ，因为 forward 可以在实参为右值时将形参转换为右值
    然后， forward 是怎么判断万能引用的实参是什么类型呢，是通过形参的类型，如果实参为左值则形参为左值引用类型，而如果实参为右值，则形参为非引用类型
    那么整理一下就是， forward 可以在形参为非引用类型时返回右值引用，而在形参为左值引用时返回左值引用
    那么为什么能这样呢，因为引用折叠
    那知道了 forward 的工作原理，我们可以试图找东西来代替原本的 T 了，而 decltype 虽然不能在 x 为右值引用时返回非引用类型，但是其返回的右值引用类型能让 forward 得出相同的结果