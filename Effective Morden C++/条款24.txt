条款24：区分万能引用和右值引用


T&& 有两种含义，一种是右值引用，他们会绑定到右值，而其存在理由在于识别出可移对象
而另一种既可以表示右值引用，也可以表示左值引用，二者居一，他们既可以绑定到右值，也可以绑定到左值，
还可以绑定到 const 对象或 非const 对象，以及 volatile 对象或 非volatile 对象，甚至既有 const 又有 volatile 的对象
被称为万能引用（因为确实是很万能

对于一个 T&& 当他涉及类型推到时为万能引用，否则就是一个右值引用

万能引用在初始化时决定他代表的时右值还是左值，对于作为函数形参的万能引用而言，在调用时决定

如果想使一个引用成为万能引用，除了要设计类型推导，还要必须形式为 T&& 才可以
别奇怪为啥会这么说，因为例如：
    template<class T>
    void f(vector<T>&& demo);
这时demo并不是一个万能引用，因为需要推导的类型是 T，而不是 vector<T>!
同样 const 修饰符也会让剥夺一个引用成为万能引用的资格，例如：
    template<class T>
    void f(const T&& demo);

而且注意，位于模板内也不能保证一定涉及类型推导
例如在 std::vector 中的 push_back(T&& x) 函数，由于对于 push_back 函数的执行是一定在创建了 vector 实体后才会进行的
也就意味着在执行 push_back 时 T 一定是被确定了的，也就是 push_back 中的 T 并不涉及类型推导，类型推导的过程在创建 vector 时执行
所以 x 是右值引用
在模板中，只有不依赖模板类型的单独类型推导的引用才可以成为万能引用
注意，调用者显示指定类型的边界情况要予以排除

还有，声明为 auto&& 类型的变量都是万能引用


原书作者说，这篇是一个谎言（抽象），底层真相称为“引用折叠(reference collapse)”，
因为是笔记，具体是啥情况现在我也不知道
甚至还有点期待