条款35：优先选择基于任务而非基于线程的程序


如果想以异步方式运行函数 doAsyncWork ，你有两个基本选择：
    你可以创建一个 std::thread 并在其上运行函数 doAsyncWork ，因此这是基于线程的途径
    还有可以把 doAsyncWork 传递给 std::async ，这种策略叫做基于任务

基于任务的方法通常比基于线程实现的对应版本要好

在基于线程的调用中，没什么办法可以直接获取 doAsyncWork 的返回值，而在基于任务的调用中 std::async 提供了 get 函数，
尤其在 doAsyncWork 抛出异常时， get 函数可以访问这个异常

基于线程和基于任务的程序设计之间更基本的区别在于，基于任务的程序设计表现着更高阶的抽象

线程在带有并发的C++软件中的三种意义：
    1.硬件线程是实际执行计算的线程
    2.软件线程（又称才做系统线程或系统线程）是操作系统用以实施跨进程管理以及进行硬件线程调度的线程
    3. std::thread 是C++进程里的对象，用作底层软件线程的句柄

软件线程是一种有限的资源，如果你试图创建的线程数量多于系统能够提供的数量，则会抛出 std::system_error 异常，这一点无论如何都会成立，即使待运行的函数不能抛出异常

解决办法有两个：
    1.在当前线程中运行 doAsyncWork 但会导致负载不均衡，而且，如果当前线程是个 GUI 线程，会导致不能响应
    2.等待某些已存在的软件线程完成工作，然后在尝试创建一个新的 std::thread 对象，但有可能已存在的线程在等待 doAsyncWork 执行的某个动作

超订问题：就绪状态的软件线程超过了硬件线程数量
超订问题发生后线程调度器会在硬件线程上分配 CPU 时间片，当一个时间片用完，另一个线程启动，就会执行语境切换，这种语境切换会增加系统的总体线程管理开销
由于软件线程和硬件线程的最佳比例取决于软件线程变成可运行状态的频繁度，而这是会动态改变的，所以避免超订是困难的
同时即使你在一个平台上解决了超订问题，也无法保证在另一种机器上你的方案仍能高效的工作

而使用 std::async 则可以将线程管理的责任交给C++标准库的实现者
调用 std::async 时，系统不保证会创建一个新线程，而是允许调度器把指定的函数运行在请求其结果的线程中，如果发生了超订和线程耗尽，系统就可以使用这个自由度

以下几种情况直接使用线程会更合适：
    1.你需要访问底层线程实现的 API
    2.你需要且有能力为你的应用优化线程用法
    3.你需要实现超越 C++ 并发API的线程技术