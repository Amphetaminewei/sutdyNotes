条款42：考虑置入而非插入


在你使用 push_back 的时候经常会遇到这样的情况
    push_back("asd");//容器保存的是 std::string 类型
而这种时候实际上编译器会发现作为参数的类型和容器保存的类型不一致，会从字符串字面量出发
去构造一个 string 也就是这样：
    push_back(std::string("asd"));
而这样会导致性能问题，这章的内容讨论也由此引发

在这段代码中，会发生两次构造，甚至可能有一次析构操作，首先构造一个 std::string 的临时变量
然后通过这个临时变量，在容器中构造一个新变量，最后析构临时变量
这繁琐的构造过程意味着严重的性能问题，对于这个问题，首先让人想到的就是怎么避免构造临时变量
解决办法就是将 push_back 换成 emplace_back ，他使用任何传入的实参在 vector 内直接构造
emplace_back 使用了完美转发，所以只要你没遇到完美转发的限制，都可以使用它
而在不需要构建临时变量的情况下， emplace_back 和 push_back 的动作是一致的
当然 emplace_back 不一定任何时候都比 push_back 更高效

如果以下情况都成立，那么置入几乎一定比插入高效：
    1.欲添加的对象是以构造而非赋值的方式加入容器，基于节点的容器几乎总是使用构造来添加新值，
    大多数标准库容器都是基于节点的
    2.传入的实参类型与容器持有类型不同
    3.容易不太可能由于重复情况而拒绝添加新值，欲检测值是否已在容器中，置入的实现一般都是使用该
    值创建一个新节点，以便将该节点与容器已有节点进行比较，如果该值已存在，节点会被析构，这意味
    着其构造和析构成本被浪费了

在选择 push_back 还是 emplace_back 的时候，还有两个问题值得操心，第一个和资源管理有关，第二个
则是他们与带有 explicit 声明修饰词的构造函数之间的互动

首先是资源问题，考虑如果你的容器持有的是智能指针类型，而你希望像容器中加入一个裸指针像这样：
    ptr.push_back(new Widget)
在使用 push_back 的情况下，从 new 构造的 Widget 会在 push_back 为其创建的临时变量析构时得到释放
而在使用 emplace_back 的情况下，抛出异常时，由于找不到这块内存（因为没有一个指向那里的指针），资源
将被泄露（看的不是很明白，我理解的是这个意思），坦率的说绝不应该把 new Widget 这样的表达式传递给大
多数函数

然后就是与带有 explicit 声明修饰词的构造函数的互动了，注意这个例子:
    std::regex r = nullptr;       //编译错误
    regexs.push_back(nullptr);    //编译错误
    regexs.emplace_back(nullptr); //编译通过！！
对就是这个问题，原本从 nullptr 到 regex 的隐式类型转换