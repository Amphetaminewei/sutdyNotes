# 2.3 程序转化语义学

      这一节将从三种初始化过程入手探究你的编译器在初始化过程中帮你做了什么
    
## 显示的初始化操作

来看一个例子：
```C++
    X x0;
    void foo_bar(){
        X x1(x0);
        X x2 = x0;
        X x3 = X(x0);
    }
```
      这是常见的三种显示初始化，会经过以下两个步骤，首先清空x1，x2，x3原本的内存，然后调用X的复制构造函数。  
经过转化后，foo_bar的代码看起来像这样：  
```C++
    void foo_bar(){
        //定义被重写，初始化操作被剥除，
        //我理解过来就是清空原本的内存
        X x1;
        X x2;
        X x3;
        //编译器安插复制构造函数
        x1.X::X(x0);
        x2.X::X(x0);
        x3.X::X(x0);
    }
```
## 参数的初始化
    把一个对象当作参数传给一个函数或作为一个函数的返回值，相当于：
    X xx = arg;
    期中xx代表形参或返回值，而arg代表实参  
    
      在编译器实现技术上，有一种策略就是导入所谓的临时对象，并调用复制构造函数将他初始化，然后将临时对象交给函数。
    即对于如下调用：
```C++
    X xx;
    //...
    foo(xx);
```
    会生成如下代码
```C++
    X __temp0;
    __temp0.X::X(xx);
    foo(__temp0);
```
      书中还提到了还需要将foo()的参数改为引用形式，我的理解是由于__temp0是在函数外初始化的，应该将其以引用的方式传入函数。也就是编译器不止是会在调用函数前生成临时对象，还会将函数的参数改为引用传参。
      这和我理解的不太一样，因为以前我的认知中，生成临时对象的过程在函数体内完成而不是调用函数前。

      另一种实现方法是以“拷贝构建”的方式把实际参数直接构建在其应该的位置，此位置视函数活动范围不同，记录于程序堆栈中。在函数返回前，局部对象的析构函数被执行。

## 返回值的初始化
已知如下函数定义：
```C++
    X bar(){
        X xx;
        //处理xx
        return xx;
    }
```
      bar()的返回值从局部对象xx中拷贝过来在cfront中的解决办法是一个双阶段转化：
    1.首先加上一个额外参数，类型是X的引用，用来放置并传递返回值；
    2.在return前插入复制构造函数，将要传回的对象复制到参数中。
    处理后的代码如下：
```C++
void bar(X& __result){
    X xx;
    xx.X::X();
    //处理xx
    __result.X::X(xx);
    return;
}
```
      看吧，这和我的原本认知也不一样，因为所有的书上都写着返回值是通过return返回的，而这里的实现显然和书上写的不一样，因为return并没有return任何东西，实际上只是做一个声明。而真正将值传递出去是通过引用传递的。

## 在使用者层面做优化

    程序员优化：定义一个计算用的构造函数
    即将这种写法：
```C++
    X bar(const T &y, const T &z){
        X xx;
        //处理xx
        return xx;
    }
```
    改为：
```C++
    X bar(const T &y, const T &z){
        return X(y,z);
    }
```
    如果看不出来优化在哪就往下看看编译器会怎么做：
```C++
    void bar(X& __result){
        __result.X::X(y, z);
        return;
    }
```
    呐，看出差别了吧，优化后的版本只进行一次构造！result直接被计算并构造，而不需要复制构造。而原本的版本呢，需要构造返回对象之外还需要构造X

## 编译器层面做优化

      在一个像bar()这样的函数中，所有的return指令传回相同的具名数值，因此编译器可能自己做优化，方法是以result参数取代named return value
      例如下面的bar()定义：
```C++
    X bar(){
        X xx;
        return xx;
    }
```
     可能被编译器优化为：
```C++
    void bar(X& __result){
        __result.X::X();
        //直接处理
        return;
    }
```
      可以发现，优化前的版本中，会先构造xx，然后对xx进行处理，然后再用xx构造__result，而优化后，将直接处理__result，而干脆不构造xx。
      这样的优化操作有时候被成为Named Return Value(NRV)优化，如今被视为标准C++编译器一个义不容辞的优化操作
      但是注意，对于没有复制构造函数的类，有时不能实施NRV优化
      虽然NRV优化提供了重要的效率改善，但他还是饱受诟病，原因之一是，优化由编译器默默完成，而他是否真的被完成并不清楚。第二个原因是，一旦函数变得比较复杂，优化也就变的比较难以施行。前两个原因都是担心优化可能失败，而第三个原因则是有些程序员不希望程序被优化，有些情况下对称性会被优化打破，程序虽然变快但却是错误的。
      一般而言，面对“一个类对象作为另一个类对象的初值”的情形，语言允许编译器有大量的自由发挥空间。好处是机器码产生时有明显的效率提升，而缺点则是你不能够安全的规划你的复制构造函数的副作用，必须视其执行而定。

## 复制构造函数要还是不要

    老样子先看段代码

```C++
    class Paint3D{
        public:
        Piont3D(float x, float y, float z);
        private:
        float _x,_y,_z;
    }
```
      上面这个类中，没有任何成员对象和基类有复制构造函数，也没有虚基类和虚函数，这个类的对象在进行“memberwise”初始化操作会导致“bitwise copy”，高效且安全，不需要复制构造函数。
      但是如果可以预见这个类需要大量的memberwised初始化操作，例如以传值的方式传回对象，那么在编译器提供NRV优化的前提下，提供复制构造函数就非常合理
      但是，如果这个类中包含虚函数或有虚基类，那么会导致那些“被编译器产生的内部members”的初值被改写！

## 摘要
    复制构造函数的应用迫使编译器多多少少对你程序代码做部分转化，尤其是当一个函数以传值的方式传回对象，而该函数有一个复制构造函数（不论是显示定义还是合成的）时。