1.1 C++对象模式


首先来看看 C++ 是怎么组织对象的模型的
简单对象模型
    对象持有一个容器，其中保存了每个成员的指针，一个对象的大小是指针的大小乘以成员的个数
    这个模型没有被应用到实际产品上，但是关于索引或 slot 个数的观念被应用到了 C++ 的“指
    向成员的指针”观念中
表格驱动对象模型
    这个模型中对象持有两个指针，分别指向成员表和成员函数表，而成员函数表也是一系列的指针
    组成，指向真正的函数
    这个模型虽然也没有实际应用，但是成员函数表这个观念却成为支持虚函数的一个有效方案
C++对象模型
    在此模型中，非静态成员被配置于每一个对象中，静态成员和成员函数则被放置在个别对象之外
    虚函数则以两个步骤支持：
        1.每个类产生一些指向虚函数的指针，放在一个被称为 virtual table 的表中（vtbl）
        2.每个类对象持有一个指向相关 vtbl 的指针，通常这个指针称为 vptr
    这个模型主要优点在于他的空间和存取时间的效率，主要缺点是如果应用程序代码本身未曾更改
    但是用到的对象的成员有所更改，则应用程序代码同样得重新编译（好像是可以通过把成员放在
    一个类内的结构体优化，记不清了
    C++ 最初采用的继承模型并不运用任何间接性，基类的成员数据直接被放置在子类中，而虚基类
    的原始模型是在对象中为每个有关联的虚基类加上一个指针
    
一头雾水对吧，我也是，至少在看完结尾的译注之前是