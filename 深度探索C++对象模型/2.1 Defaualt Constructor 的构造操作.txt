2.1 Defaualt Constructor 的构造操作


默认构造函数会在需要的时候被编译器生产出来，而这种需要指的是编译器需要而不是程序需要
简言之，编译器需要一个默认构造函数来帮他做些事情，经常发生在编译器遇到了什么问题需要，解决问题的路径之一是
寻找到一个合适的默认构造函数，这个构造函数在大多数情况下是无用的，当然这一章要讨论的是有用的情况

“带有 Defaualt Constructor ”的Member Class Object
如果一个 class 没有任何的构造函数，但它内含一个 member object，而后者有默认构造函数，则编译器将会给这个类
合成一个有用的默认构造函数，但是只有在构造函数真正被调用的时候才会发生（缓式处理

class Foo{Foo();};
class Bar{public:Foo foo; char* str;}
Bar bar;

在 bar 被创建的时候，编译器发现有一个 Foo 对象是他的成员，那么编译器有责任将他初始化，于是创建了默认构造函
数来初始化 bar 的成员 foo ，然而编译器没有责任初始化 str ，因为他是基本类型，所以被生成的默认构造函数只会
初始化 foo 而不会初始化 str
这里也再一次体现了被生成的默认构造函数是”只满足编译器需要而不是程序员需要的“

如果在本例中提供了无参构造函数并对 str 进行初始化
    Bar::Bar(){str = nullptr;}
则编译器会在原本的构造函数中插入初始化 foo 的部分，也就是编译器保证他让 foo 顺利初始化，别的他不管
如果类中有多个成员对象，则会按照他们被声明的顺序依次调用

”带有 Defaualt Constructor “的Bass Class

如果一个人没有任何构造函数的类派生自一个带有默认构造函数的基类，那么这个派生类的默认构造函数会被生成
如果设计者提供了多个构造函数但是其中都没有默认构造函数则编译器会在每个构造函数中插入所需的默认构造函
数的内容

“带有一个 Virtual Function ”的 Class
还有两种情况需要生成默认构造函数：
    1.声明或继承一个虚函数
    2.这个类派生自一个继承串链，其中有一个或更多虚基类

“带有一个 Virtual Bass Class ”的 Class
在继承体系中有虚基类的情况下，编译器需要依靠虚函数表和虚函数指针来确定成员位置，而虚函数指针会在对象构造的时候
被插入每个对象中